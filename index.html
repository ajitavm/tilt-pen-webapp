<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tilt‑Pen AR Webapp</title>
    <style>
        /* Basic reset to remove scrollbars and margins */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, Helvetica, sans-serif;
        }

        /* Container that holds the live camera feed */
        #videoContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            background: #000;
        }

        /* The video element showing the rear camera feed */
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Canvas for drawing strokes on top of the video */
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: none; /* allow touches to fall through to video */
        }

        /* Simple toolbar with controls */
        #controls {
            position: fixed;
            bottom: 16px;
            left: 0;
            width: 100%;
            z-index: 3;
            display: flex;
            justify-content: center;
            gap: 12px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: #fff;
            cursor: pointer;
        }

        button:disabled {
            background-color: #444;
            cursor: default;
        }
    </style>
</head>
<body>
    <div id="videoContainer">
        <video id="video" autoplay playsinline></video>
    </div>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="clearBtn">Clear</button>
    </div>
    <script>
        // Request access to the device's camera. We use the rear camera if available.
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact: 'environment' } }, audio: false });
                document.getElementById('video').srcObject = stream;
            } catch (err) {
                // Fallback to any camera if rear camera is unavailable
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    document.getElementById('video').srcObject = stream;
                } catch (error) {
                    console.error('Camera access denied:', error);
                }
            }
        }

        // Initialize camera on load
        startCamera();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let isRecording = false;  // Controlled by Start/Stop buttons
        let isDrawing = false;    // Internal state: are we currently drawing?
        let lastX = 0;
        let lastY = 0;

        // Variables for motion‑based displacement. When the phone is used like a
        // pen, we integrate accelerometer data over time to estimate how far
        // the device has moved across the table. Note: this is highly
        // approximate and subject to drift, but demonstrates how one might map
        // physical movement to drawing on the canvas.
        let isPenDown = false;    // True when device is tilted forward like a pen
        let velX = 0;
        let velY = 0;
        let posX = 0;
        let posY = 0;
        let lastMotionTime = null;

        // Resize canvas to fill the viewport
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearBtn = document.getElementById('clearBtn');

        startBtn.addEventListener('click', () => {
            isRecording = true;
            isDrawing = false;
            // Reset motion state on each new recording
            velX = 0;
            velY = 0;
            posX = 0;
            posY = 0;
            lastMotionTime = null;
            startBtn.disabled = true;
            stopBtn.disabled = false;
        });

        stopBtn.addEventListener('click', () => {
            isRecording = false;
            isDrawing = false;
            isPenDown = false;
            velX = 0;
            velY = 0;
            startBtn.disabled = false;
            stopBtn.disabled = true;
        });

        clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        // DeviceOrientation handler
        window.addEventListener('deviceorientation', (event) => {
            if (!isRecording) {
                // If recording is off we ignore movement completely
                return;
            }
            const beta = event.beta;   // front/back tilt, range roughly [-180, 180]
            const gamma = event.gamma; // left/right tilt, range roughly [-90, 90]

            // Only record strokes if the device is sufficiently tilted downward
            // Beta > threshold implies the phone is leaned forward like a pen
            const threshold = 40;
            // When the device is tilted forward beyond the threshold and not
            // rolled too far sideways, treat this as “pen down”.
            if (beta > threshold && Math.abs(gamma) < 60) {
                isPenDown = true;
                // If we are starting a new stroke from orientation alone,
                // initialize last positions to the center of the canvas. This
                // ensures that the first orientation‑based movement starts
                // from a known point.
                if (!isDrawing) {
                    isDrawing = true;
                    lastX = canvas.width / 2;
                    lastY = canvas.height / 2;
                }
            } else {
                // When pen is lifted, stop drawing and reset pen state
                isPenDown = false;
                isDrawing = false;
            }
        });

        // DeviceMotion handler for integration of accelerometer data. When the
        // phone is tilted like a pen (isPenDown == true) and recording is on,
        // we accumulate acceleration to approximate translation. The resulting
        // displacements are scaled and added to the canvas coordinates.
        window.addEventListener('devicemotion', (event) => {
            if (!isRecording || !isPenDown) {
                // Only integrate motion when recording and pen down
                return;
            }
            // Determine the current timestamp for integration
            const currentTime = Date.now();
            if (lastMotionTime === null) {
                lastMotionTime = currentTime;
                return;
            }
            const dt = (currentTime - lastMotionTime) / 1000; // convert ms to s
            lastMotionTime = currentTime;

            // Use acceleration without gravity if available, otherwise fall back
            const accel = event.acceleration || event.accelerationIncludingGravity;
            if (!accel) {
                return;
            }
            let ax = accel.x || 0;
            let ay = accel.y || 0;

            // Integrate acceleration to velocity and position
            velX += ax * dt;
            velY += ay * dt;
            posX += velX * dt;
            posY += velY * dt;

            // Apply a simple damping factor to reduce drift over time
            const damping = 0.98;
            velX *= damping;
            velY *= damping;

            // Scale motion to screen coordinates. These scale factors are
            // empirical and can be adjusted for sensitivity.
            const motionScale = 50; // pixels per meter approximately
            const newX = lastX + (posX * motionScale);
            const newY = lastY + (posY * motionScale);

            // Draw line from last orientation position to new integrated position
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(newX, newY);
            ctx.stroke();

            lastX = newX;
            lastY = newY;
        });
    </script>
</body>
</html>
