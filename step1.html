<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accelerometer Drawing WebApp</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        #canvas {
            border: 1px solid #000;
            background-color: #fff;
        }
        #controls {
            margin: 10px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        #status {
            margin: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <button id="start">Start</button>
        <button id="stop">Stop</button>
    </div>
    <div id="status">Status: Ready</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');

        // Set canvas size
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 100;

        let isRecording = false;
        let lastTime = 0;
        let position = { x: canvas.width / 2, y: canvas.height / 2 };
        let velocity = { x: 0, y: 0 };
        let acceleration = { x: 0, y: 0 };
        let rafId = null;

        // High-pass filter constants to reduce drift (simple alpha = 0.8)
        const alpha = 0.8;
        let gravity = { x: 0, y: 0, z: 0 };

        function updateStatus(message) {
            status.textContent = `Status: ${message}`;
        }

        async function requestPermission() {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceMotionEvent.requestPermission();
                    if (permission !== 'granted') {
                        updateStatus('Permission denied');
                        return false;
                    }
                } catch (error) {
                    updateStatus('Error requesting permission');
                    return false;
                }
            }
            return true;
        }

        function handleMotion(event) {
            if (event.accelerationIncludingGravity) {
                let acc = event.accelerationIncludingGravity;

                // Apply high-pass filter to remove gravity
                gravity.x = alpha * gravity.x + (1 - alpha) * acc.x;
                gravity.y = alpha * gravity.y + (1 - alpha) * acc.y;
                gravity.z = alpha * gravity.z + (1 - alpha) * acc.z;

                acceleration.x = acc.x - gravity.x;
                acceleration.y = acc.y - gravity.y;
                // Ignore z for 2D drawing

                // Debug: Log acceleration
                console.log(`Acc: x=${acceleration.x.toFixed(2)}, y=${acceleration.y.toFixed(2)}`);
                updateStatus(`Recording... Acc: x=${acceleration.x.toFixed(2)}, y=${acceleration.y.toFixed(2)}`);
            } else if (event.acceleration) {
                acceleration.x = event.acceleration.x;
                acceleration.y = event.acceleration.y;

                // Debug: Log acceleration
                console.log(`Acc: x=${acceleration.x.toFixed(2)}, y=${acceleration.y.toFixed(2)}`);
                updateStatus(`Recording... Acc: x=${acceleration.x.toFixed(2)}, y=${acceleration.y.toFixed(2)}`);
            } else {
                acceleration.x = 0;
                acceleration.y = 0;
            }
        }

        function drawLoop(time) {
            if (!isRecording) return;

            if (lastTime === 0) {
                lastTime = time;
            }
            const dt = (time - lastTime) / 1000; // seconds
            lastTime = time;

            // Integrate acceleration to velocity
            velocity.x += acceleration.x * dt;
            velocity.y += acceleration.y * dt;

            // Dampen velocity to reduce drift
            velocity.x *= 0.95;
            velocity.y *= 0.95;

            // Integrate velocity to position (scale for visibility, increased sensitivity)
            const scale = 50; // Increased from 10 to 50 for more sensitivity
            const deltaX = velocity.x * dt * scale;
            const deltaY = velocity.y * dt * scale;
            position.x += deltaX;
            position.y += deltaY;

            // Clamp position to canvas bounds
            position.x = Math.max(0, Math.min(canvas.width, position.x));
            position.y = Math.max(0, Math.min(canvas.height, position.y));

            // Draw line if there's movement
            if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
                ctx.beginPath();
                ctx.moveTo(position.x - deltaX, position.y - deltaY);
                ctx.lineTo(position.x, position.y);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            rafId = requestAnimationFrame(drawLoop);
        }

        document.getElementById('start').addEventListener('click', async () => {
            if (isRecording) return;

            const permitted = await requestPermission();
            if (!permitted) return;

            // Reset
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            position = { x: canvas.width / 2, y: canvas.height / 2 };
            velocity = { x: 0, y: 0 };
            acceleration = { x: 0, y: 0 };
            gravity = { x: 0, y: 0, z: 0 };
            lastTime = 0;

            window.addEventListener('devicemotion', handleMotion);
            isRecording = true;
            rafId = requestAnimationFrame(drawLoop);
            updateStatus('Recording... Move your device!');
        });

        document.getElementById('stop').addEventListener('click', () => {
            if (!isRecording) return;

            window.removeEventListener('devicemotion', handleMotion);
            isRecording = false;
            cancelAnimationFrame(rafId);
            updateStatus('Stopped');
        });

        // No initial crosshair to avoid confusion
        // ctx.beginPath();
        // ctx.moveTo(canvas.width / 2 - 10, canvas.height / 2);
        // ctx.lineTo(canvas.width / 2 + 10, canvas.height / 2);
        // ctx.moveTo(canvas.width / 2, canvas.height / 2 - 10);
        // ctx.lineTo(canvas.width / 2, canvas.height / 2 + 10);
        // ctx.strokeStyle = '#ccc';
        // ctx.stroke();
    </script>
</body>
</html>
