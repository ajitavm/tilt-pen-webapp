<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Accel Draw – step1 (world-frame + ZUPT)</title>
<style>
  body{margin:0;background:#eee;font-family:system-ui,Arial}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:10px}
  #canvas{background:#fff;border:1px solid #000;touch-action:none}
  #controls{display:flex;gap:12px}
  button{padding:10px 18px;font-size:16px;border-radius:12px;border:1px solid #bbb;background:#f8f8f8}
  #status{font:14px/1.4 system-ui;color:#555}
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="canvas" width="360" height="560"></canvas>
    <div id="controls">
      <button id="start">Start</button>
      <button id="stop" disabled>Stop</button>
    </div>
    <div id="status">Status: Ready</div>
  </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const statusEl = document.getElementById('status');

let recording = false, rafId = null, lastT = 0;

// State in canvas coordinates
let pos = { x: canvas.width/2, y: canvas.height/2 };
let vel = { x: 0, y: 0 };

// Latest sensor samples
let aBody = { x: 0, y: 0, z: 0 };      // device acceleration (m/s^2)
let euler = { alpha: 0, beta: 0, gamma: 0 }; // orientation (deg)

// Tunables
const SCALE   = 65;      // multiply integrated velocity for visible motion
const DAMPING = 0.985;   // velocity damping per frame
const ZUPT_A  = 0.12;    // if world-accel magnitude < ZUPT_A => zero velocity
const ZUPT_MS = 180;     // how long accel must be quiet to zero
let zuptTimer = 0;

// --- Permissions (iOS needs a user gesture) ---
async function ensurePermissions() {
  try {
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
      const p = await DeviceMotionEvent.requestPermission();
      if (p !== 'granted') return false;
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      const p = await DeviceOrientationEvent.requestPermission();
      if (p !== 'granted') return false;
    }
  } catch (e) {
    console.warn(e);
    return false;
  }
  return true;
}

// --- Sensor handlers ---
function onMotion(ev) {
  const acc = ev.acceleration ?? ev.accelerationIncludingGravity ?? {x:0,y:0,z:0};
  aBody.x = acc.x || 0;
  aBody.y = acc.y || 0;
  aBody.z = acc.z || 0;
}

function onOrient(ev) {
  // alpha: z-yaw (0..360), beta: x-pitch (-180..180), gamma: y-roll (-90..90)
  euler.alpha = (ev.alpha ?? 0);
  euler.beta  = (ev.beta  ?? 0);
  euler.gamma = (ev.gamma ?? 0);
}

// Rotation matrix from Z-X'-Y'' (alpha, beta, gamma) device->world
function rotMatrix(a,b,g) {
  const toRad = Math.PI/180;
  a*=toRad; b*=toRad; g*=toRad;
  const ca=Math.cos(a), sa=Math.sin(a);
  const cb=Math.cos(b), sb=Math.sin(b);
  const cg=Math.cos(g), sg=Math.sin(g);
  // Using spec orientation (may need slight sign flips per device/browser)
  return [
    [ ca*cg - sa*sb*sg,  -ca*sg - sa*sb*cg, -sa*cb ],
    [      cb*sg,               cb*cg,        -sb  ],
    [ sa*cg + ca*sb*sg,  -sa*sg + ca*sb*cg,  ca*cb ]
  ];
}

function mul3(M, v) {
  return {
    x: M[0][0]*v.x + M[0][1]*v.y + M[0][2]*v.z,
    y: M[1][0]*v.x + M[1][1]*v.y + M[1][2]*v.z,
    z: M[2][0]*v.x + M[2][1]*v.y + M[2][2]*v.z
  };
}

// Main loop: rotate accel into world, suppress drift (ZUPT), integrate
function loop(ts) {
  if (!recording) return;

  if (!lastT) lastT = ts;
  const dt = Math.max(0.001, Math.min(0.04, (ts - lastT)/1000));
  lastT = ts;

  const R = rotMatrix(euler.alpha, euler.beta, euler.gamma);

  // Convert device-frame acceleration to world-frame
  const aWorld = mul3(R, aBody);

  // Keep only planar components (x,y); ignore vertical (z)
  const ax = aWorld.x, ay = aWorld.y;
  const amag = Math.hypot(ax, ay);

  // ZUPT: if quiet long enough, zero velocity
  if (amag < ZUPT_A) {
    zuptTimer += dt*1000;
    if (zuptTimer > ZUPT_MS) { vel.x = 0; vel.y = 0; }
  } else {
    zuptTimer = 0;
  }

  // Integrate accel -> velocity
  vel.x += ax * dt;
  vel.y += ay * dt;

  // Damping to limit drift
  vel.x *= DAMPING;
  vel.y *= DAMPING;

  // Velocity -> position in pixels
  pos.x += vel.x * dt * SCALE;
  pos.y += vel.y * dt * SCALE;

  // Clamp to canvas
  pos.x = Math.max(0, Math.min(canvas.width,  pos.x));
  pos.y = Math.max(0, Math.min(canvas.height, pos.y));

  // Draw
  if (!loop.prev) loop.prev = {x: pos.x, y: pos.y};
  ctx.beginPath();
  ctx.moveTo(loop.prev.x, loop.prev.y);
  ctx.lineTo(pos.x, pos.y);
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#000';
  ctx.stroke();
  loop.prev = {x: pos.x, y: pos.y};

  statusEl.textContent =
    `Recording… aW=(${ax.toFixed(2)}, ${ay.toFixed(2)}), v=(${vel.x.toFixed(2)}, ${vel.y.toFixed(2)})`;

  rafId = requestAnimationFrame(loop);
}

function start() {
  if (recording) return;
  ensurePermissions().then(ok => {
    if (!ok) { statusEl.textContent = 'Permission denied'; return; }

    // Reset state
    ctx.clearRect(0,0,canvas.width,canvas.height);
    pos = {x: canvas.width/2, y: canvas.height/2};
    vel = {x: 0, y: 0};
    zuptTimer = 0;
    lastT = 0; loop.prev = null;

    // Start sensors
    window.addEventListener('devicemotion', onMotion, { passive: true });
    window.addEventListener('deviceorientation', onOrient, { passive: true });

    recording = true;
    document.getElementById('start').disabled = true;
    document.getElementById('stop').disabled = false;
    statusEl.textContent = 'Recording…';
    rafId = requestAnimationFrame(loop);
  });
}

function stop() {
  if (!recording) return;
  recording = false;
  window.removeEventListener('devicemotion', onMotion);
  window.removeEventListener('deviceorientation', onOrient);
  cancelAnimationFrame(rafId);
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
  statusEl.textContent = 'Stopped';
}

document.getElementById('start').addEventListener('click', start);
document.getElementById('stop').addEventListener('click', stop);

// Size canvas to viewport
function resize() {
  canvas.width  = Math.min(420, Math.round(window.innerWidth  - 40));
  canvas.height = Math.round(window.innerHeight - 180);
  ctx.fillStyle = '#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
}
window.addEventListener('resize', resize); resize();
</script>
</body>
</html>
